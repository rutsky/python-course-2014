
.. Язык программирования Python
   Лекция № 6.

.. role:: python(code)
   :language: python

.. TODO: в заголовке документа должен быть Python

=====================
Язык программирования
=====================

.. rst-class:: python-logo
.. figure:: ../common/images/python-logo-generic.svg
   :align: center

.. rst-class:: center-text

Лекция № 6

.. rst-class:: center-text

Владимир Владимирович Руцкий rutsky.vladimir@gmail.com

.. rst-class:: center-cells
.. list-table::


   * - .. image:: ../common/images/cgsg.png
          :width: 200 px
     - .. image:: ../common/images/logo_jetbrains.svg
     - .. image:: ../common/images/pml30.png
          :width: 200 px


План занятия
============

* Классы в Python. Повторение

* Итераторы

* Генераторы

* Декораторы

* Практика


Классы в Python. Повторение
===========================


Итераторы
=========

* Существует много различных контейнеров (list, tuple, str, bytes, array)

* Частая операция: пройтись по всем элементам контейнера и сделать что-то с каждым элементом

* Для унификации доступа придуман **итератор** — объект, абстрагирующий последовательный доступ к элементам контейнера

  * Контейнер предоставляет метод "создать_объект-итератор()"

  * Объект-итератор имеет метод "получить_следующий_элемент()"


Итераторы в Python
==================

* В Python метод ``__iter__()`` у контейнеров возвращает объект-итератор

* Итератор имеет метод ``__next__()`` для получения следующего значения из контейнера

* Если значений больше нет, ``__next__()`` бросает исключение ``StopIteration``


Итераторы в Python. Пример
==========================

.. literalinclude:: examples/iterator.pycon


Цикл ``for``
============

* Цикл ``for`` работает используя итераторы::

    for ELEM in CONTAINER:
        PROCESS(ELEM)

  эквивалентно::

    it = CONTAINER.__iter__()
    while True:
        try:
            ELEM = it.__next__()
        except StopIteration:
            break

        PROCESS(ELEM)

* Замечание: ``for`` также поддерживает протокол последовательности (``sequence protocol``)

Написание итераторов
====================

.. literalinclude:: examples/iterator_class.pycon


Передача последовательностей
============================

* Большинство функций работает с контейнерами через итераторы::

    >>> list(MyRange(10))
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> list(zip(MyRange(3), MyRange(5)))
    [(0, 0), (1, 1), (2, 2)]

* *Интерфейс* итератора скрывает детали того, как именно *итерироваться* (проходить) по элементам

* Многие функции возвращают объекты поддерживающие итерфейс итераторов::

    >>> res = zip(range(10), ['A', 'B'])
    >>> it = res.__iter__()
    >>> it.__next__()
    (0, 'A')
    >>>

``__iter__()`` у итераторов
===========================

* Замечание: итераторы также имеют метод __iter__(), который возвращает самого себя

  * В функцию можно передать как контейнер, так и итератор

  * Функция может вернуть как контейнер, так и итератор

* По умолчанию стоит считать, что функция принимает/возвращает контейнер,
  но работать с ним через интерфейс итератора

Функция :py:func:`iter`
=======================

* ``iter(object[, sentinel])`` — обёртка для получения итератора из контейнера

* С одним аргументом возвращает результат ``object.__iter__()``

* С двумя аргументами возвращает итератор, который вызывает ``object``, пока
  он не вернёт ``sentinel``::

    f = open('mydata.txt')
    for line in iter(f.readline, ''):
        process_line(line)


Функция :py:func:`next`
=======================

* ``next(iterator[, default])`` — возвращает следующий элемент интератора
  (вызывая ``__next__()``)

  * Если указан default, то когда итератор завершится (бросит исключение StopIteration),
    будет возвращаться default


.. rst-class:: smaller

Пример
======

.. literalinclude:: examples/iter_next.pycon


Возможности итераторов
======================

* Интерфейс итератора абстрагирует доступ к элементам контейнера

* Позволяет создавать "виртуальные" последовательности

  * Не обязательно хранить все элементы, если можно создавать их "на лету"


Реализация собственных итераторов через реализацию ``__iter__()``, ``__next__()``
довольно трудоёмкий процесс, можно прощё!


.. rst-class:: smaller2

Генераторы
==========

.. literalinclude:: examples/yield.pycon


Пример
======

.. literalinclude:: examples/range_with_yield.pycon


.. rst-class:: smaller

``yield from``
==============

.. literalinclude:: examples/yield_from.pycon


.. rst-class:: smaller2

Передача значений в ``yield``
=============================

.. literalinclude:: examples/yield_send.pycon


.. rst-class:: smaller

Выражения генераторы
====================

.. literalinclude:: examples/generator_expr.pycon


Возможности генераторов
=======================

* Генераторы позволяют создавать **сопрограммы** (**coroutines**) —
  обобщёная подпрограмма, которая имеет несколько точек входа,
  возможность остановки выполнения и возможность продолжения выполнения
  из того же состояния

* Возможность остановить работу функции и затем продолжить её позволяет делать
  различные трюки

  * Фреймворк Twisted на генераторах реализует асинхронное программирование

Декораторы
==========

* При создании функции можно сделать "постобработку" полученной функции с помощью **декоратора**

* Синтаксис::

      @my_decorator
      def func():
          pass

  эквивалентно::

      def func():
          pass

      func = my_decorator(func)


.. rst-class:: smaller2

Пример
======

.. literalinclude:: examples/decorator.pycon


Комбинирование декораторов
==========================

* Можно использовать несколько декораторов и передавать аргументы в декораторы::

      @dec1
      @dec2(1, 2)
      @dec3()
      def func():
          pass

  эквивалентно::

      def func():
          pass

      func = dec3()(func)
      func = dec2(1, 2)(func)
      func = dec1(func)

Практика
========


.. Язык программирования Python
   Лекция № 3.

.. role:: python(code)
   :language: python

.. TODO: в заголовке документа должен быть Python

=====================
Язык программирования
=====================

.. rst-class:: python-logo
.. figure:: ../common/images/python-logo-generic.svg
   :align: center

.. rst-class:: center-text

Лекция № 3

.. rst-class:: center-text

Владимир Владимирович Руцкий rutsky.vladimir@gmail.com

.. rst-class:: center-cells
.. list-table::


   * - .. image:: ../common/images/cgsg.png
          :width: 200 px
     - .. image:: ../common/images/logo_jetbrains.svg
     - .. image:: ../common/images/pml30.png
          :width: 200 px


План занятия
============

* Строки, ввод/вывод, механизм исключений

* Практика


.. rst-class:: smaller2

Строки. Повторение (1/2)
========================

* Строки — последовательности:

.. literalinclude:: examples/str_sequences.pycon

* Строки — неизменяемые:

.. literalinclude:: examples/str_immutable.pycon


.. rst-class:: smaller2

Строки. Повторение (2/2)
========================

* Различные способы задания:

.. literalinclude:: examples/str_definition.pycon


.. rst-class:: smaller3

Символы и кодировки
===================

* На экране монитора, бумаге, табличках изображаются **символы**

  * символ: «маленькая кириллическая буква А»
  * изображение: «а»,

* Для хранения символа в памяти компьютера, ему необходимо сопоставить численное представление — **закодировать символ**

* Для кодирования используются различные **кодировки**

* Ранее были распространены однобайтовые кодировки: один символ — один байт

  * Для кириллицы часто использовались ``cp1251``, ``koi8-r``, ``MacCyrillic``

  * Символ: «маленькая кириллическая буква А»: ``cp1251`` — 0xE0, ``koi8-r`` — 0xC1, ``MacCyrillic`` — 0xE0.

* Однобайтные кодировки — ужасны

  * не могут хранить все символы, необходимо переключаться между кодировками для разных языков

  * для файла нужно знать его кодировку, иначе — «кракозябры» (кодировок очень много)


.. rst-class:: smaller3

Unicode
=======

* `Unicode <https://ru.wikipedia.org/wiki/Unicode>`_ — стандарт описывающий все символы всех языков (+ иконки, модификаторы и т.п.)

* Каждому символу ставится в соответствие **кодовая позиция Unicode**

  *  «маленькая кириллическая буква А» — ``U+0430``

* Для хранения кодовых позиций Unicode в памяти компьютера позиции **кодируются**

* Есть ряд **кодировок** хранения кодовых позиций Unicode в памяти (Unicode Transformation Format):

  * UTF-8 — каждый символ кодируется последовательностью от 1 до 6 байт
  * UTF-16 — каждый символ кодируется последовательностью 2 или 4 байта 
  * UTF-32 — каждый символ кодируется 4 байтами, числом — кодовой позицией

* код символа «маленькая кириллическая буква А» (``U+0430``)

  * в UTF-8: 0xd0 0xb0,
  * в UTF-16 0x30 0x04,
  * в UTF-32 0x30 0x04 0x00 0x00

.. rst-class:: smaller3

Unicode в Python
================

* Строки в Python — это Unicode строки

  * конкретный формат представления в памяти зависит от платформы и настроек компиляции Python

* По умолчанию исходный код файлов считается в UTF-8

  * Это можно изменить, добавив первой строкой комментарий с кодировкой, например::

    # coding: cp1251

.. literalinclude:: examples/unicode.pycon


.. rst-class:: smaller2

Байтовые последовательности
===========================

.. literalinclude:: examples/bytes.pycon


.. rst-class:: smaller2

Работа со строками (1/2)
========================

.. literalinclude:: examples/str_methods.pycon


.. rst-class:: smaller2

Работа со строками (2/2)
========================

.. literalinclude:: examples/str_methods2.pycon


.. rst-class:: smaller2

Ввод/вывод в Python
===================

.. literalinclude:: examples/open.pycon


.. rst-class:: smaller2

Стандартные потоки ввода/вывода
===============================

.. literalinclude:: examples/stdinout.pycon


.. rst-class:: smaller2

Типы ошибок
===========

* Синтаксические ошибки — возникают при загрузке модуля
  (разборе очередной строки в интерактивном режиме)

  .. literalinclude:: examples/exc_syntax_error.pycon

* Фатальные ошибки внутри интерпретатора Python или библиотек

  .. TODO: размер шрифта, если подпункт

  Crash. «Программа совершила недопустимую операцию и будет закрыта»

* Ошибки времени выполнения — **исключительные ситуации**

  .. literalinclude:: examples/exc_runtime_error.pycon

Исключительные ситуации
=======================

* Популярный механизм обработки ошибок

* Деление на ноль, закончилась память, не удалось открыть файл и др. —
  **исключительные ситуации**

* Все исключения имеют:

  * **тип** — класс исключения,

  * **объект-исключение** — может хранить дополнительную информацию

* Для обработки исключений используется конструкция::

    try:
        # БЛОК-КОДА
        ...
    except ...: # ОПИСАНИЕ ТИПА ИСКЛЮЧЕНИЯ
        # БЛОК-ОБРАБОТЧИКА-ИСКЛЮЧЕНИЯ
        ...


.. rst-class:: smaller3

Обработка исключительных ситуаций
=================================

.. code-block:: py3

   # блок кода 1
   try:
       ... # блок кода 2
   except ExceptionType1:
       ... # блок обработки исключения ExceptionType1
   except ExceptionType2:
       ... # блок обработки исключения ExceptionType2
   # Продолжение блока кода 1

Если в *блоке кода 2* происходит необработанная исключительная ситуация, то:

* создаётся объект-исключение (класс + данные), назовём его ``exc``

* *блок кода 2* прерывается в месте, где произошло исключение

* среди конструкций ``except`` последовательно ищется блок с подходящим типом
  исключения (по типу исключения)

  * если обработчик найден, то выполняется его блок, затем упраление передаётся
    в продолжение блока кода 1

  * если обоработчик не найдён, то исключение не обработано и произойдёт
    переход к внешнему ``try-except`` обработчику исключений
    (если его нет, то программа завершится с ошибкой)


Пример
======

.. literalinclude:: examples/exc_value_type.pycon

.. literalinclude:: examples/exc_example.py


.. rst-class:: smaller2

Конструкция ``try-except``
==========================

.. literalinclude:: examples/exc_syntax.py


.. rst-class:: smaller3

Иерархия исключений
===================

.. list-table::

   * - * исключения образуют иерархию по типам

       *  Обработчик с типом ``T`` подходит
          для исключения с типом  ``type(exc)``, если

          * ``type(exc) == T``, или
          * ``type(exc)`` *наследуется* от ``T``

          Или просто::
          
            if isinstance(exc, T):
                ...

     - .. code-block:: none

          BaseException
           +-- SystemExit
           +-- KeyboardInterrupt
           +-- GeneratorExit
           +-- Exception
                +-- StopIteration
                +-- ArithmeticError
                |    +-- FloatingPointError
                |    +-- OverflowError
                |    +-- ZeroDivisionError
                +-- AssertionError
                +-- AttributeError
                +-- BufferError
                +-- EOFError
                +-- ImportError
                +-- LookupError
                |    +-- IndexError
                |    +-- KeyError
                +-- MemoryError
                +-- NameError
                |    +-- UnboundLocalError
                +-- OSError 
                ...

.. rst-class:: smaller3

Порождение исключений
=====================

*Вызвать* (*породить*, *бросить*) исключение можно явно::

  raise some_object

Пример:

  .. literalinclude:: examples/exc_raise.pycon


.. rst-class:: smaller3

Конструкция ``try-finally``
===========================

Есть синтаксис для гарантированного выполнения кода::

  try:
      ... # блок кода 1
  except SomeExcType:
      ... # блок кода except
  finally:
      ... # блок кода finally
  ... # продолжение блока кода

* Если

    * *блок кода 1* не бросил исключения

    * *блок кода 1* бросил исключение, но оно было обработано в ``except``

  то перед выполнением *продолжения блока кода* выполнится *блок кода finally*

* Если

    * *блок кода 1* бросил исключение и оно не было поймано в ``except``

    * *блок кода 1* бросил исключение, оно было поймано ``except``, но внутри *блока кода except* произошло непойманное исключение

  то перед переходу к внешнему обработчику исключений выполнится *блок кода finally*

Пример ``finally``
==================

.. code-block:: py3

   f = open("test.txt")
   try:
      ...       # обработка содержимого файла
   finally:
      f.close() # выполнится всегда после завершения блока try

.. code-block:: py3

   try:
       main()
   finally:
       print("Good bye!")

Практика
========
